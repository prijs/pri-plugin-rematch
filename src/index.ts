import * as fs from 'fs-extra';
import * as _ from 'lodash';
import * as normalizePath from 'normalize-path';
import * as path from 'path';
import * as prettier from 'prettier';
import { pri, tempJsEntryPath, tempPath, tempTypesPath } from 'pri';
import { judgeHasComponents } from './methods';

interface IResult {
  projectAnalyseRematch: {
    modelFiles: Array<{
      name: string;
      file: path.ParsedPath;
    }>;
  };
}

const safeName = (str: string) => _.camelCase(str);

export default async (instance: typeof pri) => {
  const modelRoot = 'src/models';
  const projectRootPath = instance.project.getProjectRootPath();

  const modelFilePath = path.join(projectRootPath, tempTypesPath.dir, 'models.ts');
  const modelFilePathInfo = path.parse(modelFilePath);

  /** Support pri/models alias */
  instance.build.pipeConfig((env, config) => {
    if (!config.resolve.alias) {
      config.resolve.alias = {};
    }

    config.resolve.alias['pri/models'] = modelFilePath;

    return config;
  });

  /** Set white files */
  const whiteList = [modelRoot];
  instance.project.whiteFileRules.add(file => {
    return whiteList.some(whiteName => path.format(file) === path.join(projectRootPath, whiteName));
  });

  // src/models/**
  instance.project.whiteFileRules.add(file => {
    const relativePath = path.relative(projectRootPath, file.dir);
    return relativePath.startsWith(modelRoot);
  });

  instance.project.onAnalyseProject(files => {
    return {
      projectAnalyseRematch: {
        modelFiles: files
          .filter(file => {
            if (file.isDir) {
              return false;
            }

            const relativePath = path.relative(projectRootPath, path.join(file.dir, file.name));

            if (!relativePath.startsWith(modelRoot)) {
              return false;
            }

            return true;
          })
          .map(file => {
            return { file, name: safeName(file.name) };
          })
      }
    } as IResult;
  });

  instance.project.onCreateEntry((analyseInfo: IResult, entry, env, projectConfig) => {
    if (analyseInfo.projectAnalyseRematch.modelFiles.length === 0) {
      return;
    }

    const entryRelativeToModels = ensureStartWithWebpackRelativePoint(
      path.relative(path.join(tempJsEntryPath.dir), path.join(modelFilePathInfo.dir, modelFilePathInfo.name))
    );

    entry.pipeAppHeader(header => {
      return `
        ${header}
        import { Provider } from 'react-redux'
        import rematchStore from "${normalizePath(entryRelativeToModels)}"
      `;
    });

    entry.pipeAppRouter(router => {
      return `
        <Provider store={rematchStore}>
          ${router}
        </Provider>
      `;
    });

    const modelsContent = `
      import { init } from '@rematch/core'
      import { connect as reduxConnect } from 'react-redux'

      ${analyseInfo.projectAnalyseRematch.modelFiles
        .map(modelFile => {
          const importAbsolutePath = path.join(modelFile.file.dir, modelFile.file.name);
          const importRelativePath = ensureStartWithWebpackRelativePoint(
            path.relative(modelFilePathInfo.dir, importAbsolutePath)
          );
          return `import ${modelFile.name} from "${normalizePath(importRelativePath)}"`;
        })
        .join('\n')}

      const models = {${analyseInfo.projectAnalyseRematch.modelFiles
        .map(storeFile => {
          return `${storeFile.name}`;
        })
        .join(',')}}

      const store = init({models})
      export default store

      // Strong type connect
      type IMapStateToProps = (
        state?: {
          ${analyseInfo.projectAnalyseRematch.modelFiles
            .map(modelFile => {
              return `${modelFile.name}: typeof ${modelFile.name}.state;`;
            })
            .join('\n')}
        },
        props?: any
      ) => object;

      type IMapDispatchToProps = (
        dispatch?: {
          ${analyseInfo.projectAnalyseRematch.modelFiles
            .map(modelFile => {
              return `${modelFile.name}: typeof ${modelFile.name}.reducers & typeof ${modelFile.name}.effects;`;
            })
            .join('\n')}
        }
      ) => object;

      export const connect = (mapStateToProps?: IMapStateToProps, mapDispatchToProps?: IMapDispatchToProps) => {
        return reduxConnect(mapStateToProps, mapDispatchToProps) as any;
      };
    `;

    // If has stores, create helper.ts
    fs.outputFileSync(
      modelFilePath,
      prettier.format(getHelperContent(modelsContent), {
        semi: false,
        parser: 'typescript'
      })
    );
  });
};

function getHelperContent(str: string) {
  return `
    /**
     * Do not edit this file.
     * This file is automatic generated to get type help.
     */
    ${str}
  `;
}

export function ensureStartWithWebpackRelativePoint(str: string) {
  if (str.startsWith('/')) {
    throw Error(`${str} is an absolute path!`);
  }

  if (!str.startsWith('./') && !str.startsWith('../')) {
    return './' + str;
  } else {
    return str;
  }
}
